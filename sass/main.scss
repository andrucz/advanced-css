$color-primary: #55c57a;
$color-primary-light: #7ed56f;
$color-primary-dark: #28b485;

$color-white: #fff;
$color-gray-dark: #777;
$color-black: #000;

*,
*::after,
*::before {
  margin: 0;
  padding: 0;
  box-sizing: inherit;
}

html {
  font-size: 62.5%; /* it's easier to calculate relative sizes using 10 as a reference (16px default size * 62.5%) */
}

body {
  font-family: 'Lato', sans-serif;
  font-weight: 400;
  line-height: 1.7;
  color: $color-gray-dark;
  padding: 3rem;
  box-sizing: border-box;
}

.header {
  height: 95vh; /* 95% of viewport height */
  background-image: linear-gradient(
    to right bottom, 
    rgba($color-primary-light, 0.8),
    rgba($color-primary-dark, 0.8)),
    url(../img/hero.jpg);
  background-size: cover;
  background-position: top;
  position: relative;
  clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%);

  &__logo-box {
    position: absolute;
    top: 4rem;
    left: 4rem;
  }

  &__logo {
    height: 3.5rem;
  }

  &__text-box {
    position: absolute;
    top: 40%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
  }
}

.heading-primary {
  color: $color-white;
  text-transform: uppercase;

  backface-visibility: hidden; /* prevents the element from being shaken after animations */
  margin-bottom: 6rem;

  &--main {
    display: block;
    font-size: 6rem;
    font-weight: 400;
    letter-spacing: 3.5rem;
  
    animation-name: moveInLeft;
    animation-duration: 1s;
    animation-timing-function: ease-out;
  
    /*
    animation-delay: 3s;
    animation-iteration-count: 3;
    */
  }

  &--sub {
    display: block;
    font-size: 2rem;
    font-weight: 700;
    letter-spacing: 1.75rem;
    animation: moveInRight 1s ease-out;
  }
}

@keyframes moveInLeft {
  /* animation start */
  0% {
    opacity: 0;
    transform: translateX(-10rem);
  }

  80% {
    transform: translateX(1rem);
  }

  /* animation end */
  100% {
    opacity: 1;
    transform: translate(0);
  }
}

@keyframes moveInRight {
  /* animation start */
  0% {
    opacity: 0;
    transform: translateX(10rem);
  }

  80% {
    transform: translateX(-1rem);
  }

  /* animation end */
  100% {
    opacity: 1;
    transform: translate(0);
  }
}

@keyframes moveInBottom {
  /* animation start */
  0% {
    opacity: 0;
    transform: translateY(3rem);
  }

  /* animation end */
  100% {
    opacity: 1;
    transform: translateY(0);
  }
}

.btn {
  &:link,
  &:visited {
    text-transform: uppercase;
    text-decoration: none;
    padding: 1.5rem 4rem;
    display: inline-block;
    border-radius: 10rem;
    transition: all .2s;
    position: relative;
    font-size: 1.6rem;
  }
  
  &:hover {
    transform: translateY(-.3rem);
    box-shadow: 0 1rem 2rem rgba($color-black, .2);

    &::after {
      transform: scaleX(1.4) scaleY(1.6);
      opacity: 0;
    }
  }
  
  &:active {
    transform: translateY(-.1rem);
    box-shadow: 0 .5rem 1rem rgba($color-black, .2);
  }
  
  &--white {
    background-color: $color-white;
    color: $color-gray-dark;

    &::after {
      background-color: $color-white;
    }
  }
  
  &::after {
    content: '';
    display: inline-block;
    height: 100%;
    width: 100%;
    border-radius: 10rem;
    position: absolute;
    top: 0;
    left: 0;
    z-index: -1;
    transition: all .4s;
  }
  
  &--animated {
    animation: moveInBottom .5s ease-out .75s;
    animation-fill-mode: backwards; /* ensures that other animation values are applied before starting this one */
  }
}

/*
- CSS declarations marked with !important have the highest priority;
- But, only use !important as a last resource. It's better to use the correct specifities - more maintainable code!

- Inline styles will always have priority over styles in external stylesheets;
- A selector that contains 1 ID is more specific than one with 1000 classes;

- The universal selector * has no specificity value (0, 0, 0, 0);
- Rely more on specificity than on the order of selectors;
- But, rely on order when using 3rd-party stylesheets - always put your author stylesheet last.
*/

/*
How units are converted from relative to absolute (px)

% (fonts): 150% ---> x% * parent's computed size --------------> 16px * 150% = 24px
% (lengths): 10% --> x% * parent's computed width -------------> 1000px * 10% = 100px
em (fonts): 3em ---> x * parent's computed font-size ----------> 16px * 3 = 48px
em (lengths): 2m --> x * current element computed font-size ---> 24px * 2 = 48px
rem: 10rem --------> x * root computed font-size --------------> 16px * 10 = 160px
vh: 90vh ----------> x * 1% of viewport height ----------------> 90 * 1% = 90% of current viewport height
vw: 80vw ----------> x * 1% of viewport width -----------------> 80 * 1% = 80% of current viewport width
*/

/*
THE BOX MODEL

HEIGHTS AND WIDTHS:
total width = right border + right padding + specified width + left padding + left border
total height = top border + top padding + specified height + bottom padding + bottom border

box-sizing: border-box
total width: specified width
total height: specified height
###

BOX TYPES:
# display: block
Element formatted visually as a block
100% of parent's width
Vertically, one after another
box-model applies (considers height and width)

# display: inline
Content is distributed in lines
Occupies only content's space
No line-breaks
/!\ No heights and widths
/!\ Paddings and margins only horizontal (left and right)

# display: inline-block
A mix of block and inline
box-model applies (considers height and width)
###

POSITIONING SCHEMES
# Normal flow
Default positioning scheme
NOT floated
NOT absolutely positioned
Elements laid out according to their source order

# Floats
Element is removed from the normal flow
Text and inline elements will wrap around the floated element
The container will not adjust its height to the element

# Absolute positioning
Element is removed from the normal flow
No impact on surrounding content or elements
We use top, bottom, left and right to offset the element from its relatively positioned container
*/
